#!/usr/bin/env python

# Copyright (C) 2009-2012:
#    Gabes Jean, naparuba@gmail.com
#    Gerhard Lausser, Gerhard.Lausser@consol.de
#    Gregory Starck, g.starck@gmail.com
#    Hartmut Goebel, h.goebel@goebel-consult.de
#
# This file is part of Shinken.
#
# Shinken is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Shinken is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Shinken.  If not, see <http://www.gnu.org/licenses/>.

"""

Warning: THIS IS A PREVIEW, and ugly code that looks as a script.

"""

import optparse
import sys
import os
import re
import tempfile
import json
import shutil
import zipfile
import tarfile
import pycurl
import urllib
import ConfigParser
import imp
import shlex
import readline
from StringIO import StringIO

try:
    import shinken
    from shinken.bin import VERSION
except ImportError:
    # If importing shinken fails, try to load from current directory
    # or parent directory to support running without installation.
    # Submodules will then be loaded from there, too.
    import imp
    imp.load_module('shinken', *imp.find_module('shinken', [os.path.realpath("."), os.path.realpath(".."), os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), "..")]))
    from shinken.bin import VERSION

from shinken.log import logger, cprint
from shinken.objects.config import Config


logger.set_level(logger.DEBUG)
logger.set_display_time(False)

CONFIG = {}

class Dummy():
    def __init__(self): pass

    def add(self, obj): pass
logger.load_obj(Dummy())


if os.name != 'nt':
    DEFAULT_CFG = os.path.expanduser('~/.shinken.ini')
else:
    DEFAULT_CFG = 'c:\\shinken\\etc\\shinken.ini'




# Commander is the main class for managing the CLI session and behavior
class CLICommander(object):
    def __init__(self, config):
        self.keywords = {}
        self.config = config
        #We will now try to load the keywords from the modules
        self.load_cli_mods()

        self.completion_matches = []
        

    def load_cli_mods(self):

        # Main list of keywords for the first parameter
        self.keywords = {}
        cli_mods_dir = os.path.abspath(self.config['paths']['cli'])
        logger.debug ("WILL LOAD THE CLI DIR %s" %  cli_mods_dir)
        cli_mods_dirs = [os.path.join(cli_mods_dir, d) for d in os.listdir(cli_mods_dir) if os.path.isdir(os.path.join(cli_mods_dir, d))]
        print "BLA?", cli_mods_dirs
        for d in cli_mods_dirs:
            f = os.path.join(d, 'cli.py')
            print "EXISTS?", f
            if os.path.exists(f):
                dname = os.path.split(d)[1]
                # Let's load it, but first att it to sys.path
                sys.path.append(d)
                # Load this PATH/cli.py file
                m = imp.load_source(dname, f)
                # Link the CONFIG objet into it
                m.CONFIG = self.config
                exports = getattr(m, 'exports', {})
                for (f, v) in exports.iteritems():
                    m_keywords = v.get('keywords', [])
                    for k in m_keywords:
                        e = {'f':f, 'args' : v.get('args', []),
                             'description':v.get('description', '')}
                        # Finally save it
                        self.keywords[k] = e
                         
        logger.debug('We load the keywords %s' % self.keywords)


    def loop(self):
        print "CALLING LOOP!"
        readline.parse_and_bind('tab: complete')
        # Use the CLI as completer
        readline.set_completer(self.complete)


        readline.parse_and_bind('set editing-mode emacs')
        # Try to read and save the history when exiting
        histfile = os.path.join(os.path.expanduser("~"), ".shinken.history")
        try:
            readline.read_history_file(histfile)
        except IOError:
            pass
        import atexit
        atexit.register(readline.write_history_file, histfile)

        while True:
            try:
                line = raw_input('> ')
            except EOFError:
                print ''
                break
            line = line.strip()
            if line in ['quit', 'bye', 'sayonara']:
                break

            if not line:
                continue
            if line.startswith('!'):
                self.execute_shell(line[1:])
                continue
            # More cleassic command
            print 'ENTERED: "%s"' % line
            args = shlex.split(line.encode('utf8', 'ignore'))
            print "WANT TO CALL WITH ARGS", args
            self.one_loop(args)
            

    
    def execute_shell(self, line):
        output = os.popen(line).read()
        print output


    # Execute a function based on the command line
    def one_loop(self, command_args):
        print "ARGS", command_args
        keyword = command_args.pop(0)
        mod = self.keywords.get(keyword, None)
        if mod is None:
            logger.error("UNKNOWN command %s" % keyword)
            return
        
        # Now prepare a new parser, for the command call this time
        command_parser = optparse.OptionParser(
            """""",
            version="%prog " + VERSION)
        command_parser.prog = keyword

        f_args = []
        for a in mod.get('args', []):
            n = a.get('name', None)
            if n is None:
                continue
            default = a.get('default', Dummy)
            description = a.get('description', '')
        
        print "PARSE"
        cmd_opts, cmd_args = command_parser.parse_args(command_args)
        print "FIN PARSE"

        print "Load mod", mod

        f = mod.get('f', None)
        print "CALLING", f, "WITH", cmd_args
        f(*cmd_args)




    # Complete is a bit strange in readline. It will call it as it do not answser None, by increasing the
    # state int for each call. So don't loop forever!
    def complete(self, text, state):
        #print "STATE?", text, state

        # New completion call
        if state == 0:
            self.completion_matches = []
        
        #print "TRY TO COMPLETE", text
        text = text.strip()
        
        args = shlex.split(text.encode('utf8', 'ignore'))
        #print "ARGS", args
        if len(args) == 0:
            args = ['']
        keyword = args[0]
        # Trying to expand the command name
        if len(args) == 1 and state == 0:
            for k in self.keywords:
                if k.startswith(text):
                    self.completion_matches.append(k)
        
        response = None
        try:
            response = self.completion_matches[state]
        except IndexError:
            response = None

        #print "CALL", text, "state", state, response
        return response
                

if __name__ == '__main__':
    parser = optparse.OptionParser(
        """""",
        version="%prog " + VERSION)
    parser.add_option('--proxy', dest="proxy",
                      help="""Proxy URI. Like http://user:password@proxy-server:3128""")
    parser.add_option('-A', '--api-key',
                      dest="api_key", help=("Your API key for uploading the package to the Shinken.io website. If you don't have one, please go to your account page"))
    parser.add_option('-l', '--list', action='store_true',
                      dest="do_list", help=("List available commands"))
    

    if not os.path.exists(DEFAULT_CFG):
        logger.debug('Missing configuration file!')
    else:
        cfg = ConfigParser.ConfigParser()
        cfg.read(DEFAULT_CFG)
        for section in cfg.sections():
            if not section in CONFIG:
                CONFIG[section] = {}
            for (key, value) in cfg.items(section):
                CONFIG[section][key] = value

    CLI = CLICommander(CONFIG)

    
    # We should look on the sys.argv if we find a valid keywords to
    # call in one loop or not.
    def hack_sys_argv():        
        command_values = []
        internal_values = []
        #print "RARGS", parser.rargs
        founded = False
        for arg in sys.argv:
            if arg in CLI.keywords:
                founded = True
            # Did we found it?
            if founded:
                command_values.append(arg)
            else: # ok still not, it's for the shinekn command so
                internal_values.append(arg)

        sys.argv = internal_values
        return command_values
            
    # We will remove specific commands from the sys.argv list and keep
    # them for parsing them after
    command_args = hack_sys_argv()

    # Global command parsing
    opts, args = parser.parse_args()

    # If the user explicitely set the proxy, take it!
    if opts.proxy:
        CONFIG['shinken.io.proxy'] = opts.proxy

    # Maybe he/she just want to list our commands?
    if opts.do_list:
        print "Available commands:"
        for (k,m) in CLI.keywords.iteritems():
            cprint('%s ' %  k , 'green', end='')
            cprint(': %s' %  m['description'])
        sys.exit(2)
    
    # if just call shinken, we must open a prompt, but will be for another version
    if len(command_args) == 0:
        CLI.loop()
        sys.exit(0)

    # If it's just a one call shot, do it!
    CLI.one_loop(command_args)
    
